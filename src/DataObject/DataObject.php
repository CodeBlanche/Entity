<?php

namespace DataObject;

use \Iterator,
    \Serializable,
    \ReflectionClass,
    \ReflectionProperty,
    \Cloneable\Cloneable,
    \DataObject\Exception\RuntimeException;

/**
 * This class is intended to be used as a base for pure data object classes
 * that contain typed (using phpdoc) public properties. Control over these
 * properties is deferred to DataObject in order to validate inputs and auto-
 * matically cast values to the correct types.
 *
 * @author      Merten van Gerven
 * @package     DataObject
 * @dependency  Cloneable
 */
abstract class DataObject extends Cloneable implements Iterator, Serializable
{
    protected static $do_cache = array();

    /**
     * Pipe seperated list of supported native (is_*) types for validation.
     */

    const TYPE_MAP_ALLOWED = 'array|bool|callable|double|float|int|integer|long|null|numeric|object|real|resource|scalar|string';

    /**
     * Pipe seperated list of supported native $var = (*) $var cast types.
     */
    const CAST_MAP_ALLOWED = 'int|integer|bool|boolean|float|double|real|string|unset';
    const HASH_TYPE_SHA256 = 'sha256';
    const HASH_TYPE_MD5 = 'md5';

    /**
     * Data Object class instance type.
     *
     * @var string
     */
    protected $called_class;

    /**
     * Maps phpdoc types to native (is_*) and/or user defined (instancof) types
     * for validation.
     *
     * @var array
     */
    protected $type_map = array(
        'boolean' => 'bool',
        'int' => 'numeric',
        'integer' => 'numeric',
        'double' => 'numeric',
        'float' => 'numeric',
        '*' => 'object', // Default: if type not found or supported
    );

    /**
     * Maps phpdoc types to native types for casting.
     *
     * @var array
     */
    protected $cast_map = array(
        'null' => 'unset',
    );

    /**
     * Keys of public properties declared within DataObject extendor.
     *
     * @var array
     */
    protected $definition_keys = array();

    /**
     * Keys of undeclared dynamic public properties.
     */
    protected $dynamic_keys = array();

    /**
     * Types of public properties declared within DataObject extendor.
     *
     * @var array
     */
    protected $definition_types = array();

    /**
     * Types of undeclared dynamic public properties.
     */
    protected $dynamic_types = array();

    /**
     * Values of public properties declared within DataObject extendor.
     *
     * @var array
     */
    protected $definition_values = array();

    /**
     * Values of undeclared dynamic public properties.
     */
    protected $dynamic_values = array();

    /**
     * Default property values declared within DataObject extender.
     *
     * @var array
     */
    protected $definition_defaults = array();

    /**
     * Iterator implementation placeholder.
     *
     * @var integer
     */
    private $iterator_pos = 0;

    private static $exceptions = array(
        1 => "'%s' indicates a 'mixed' type in phpdoc for property '%s' of class '%s'. Please use 'mixed' instead.",
        2 => "'%s' is not a valid native or object/class type in phpdoc for property '%s' of class '%s'",
        3 => "'%s' is not a supported map type value while adding '%s' to type map.",
        4 => "'%s' is not a supported cast type value while adding '%s' to cast map.",
        5 => "Attempt to get type for property '%s' of class '%s' failed. Property does not exist.",
        6 => "Attempt to access property '%s' of class '%s' failed. Property does not exist.",
        7 => "Attempt to set property '%s' of class '%s' failed. Property does not exist.",
        8 => "Attempt to set property '%s' of class '%s' failed. Property type '%s' expected while type '%s' was given for value '%s'",
        9 => "Attempt to unset property '%s' of class '%s' failed. Property does not exist.",
        10 => "Attempt to cast value to invalid type '%s'",
        11 => "Could not unserialize %s in %s",
        11 => "Could not unserialize %s in %s",
    );

    /**
     * Export DataObject internal cache for custom cross session caching.
     *
     * @return string Serialized cache array.
     */
    final public static function ExportCache()
    {
        return serialize(self::$do_cache);
    }

    /**
     * Import DataObject internal cache from custom cross session caching.
     *
     * @param string $cache Serialized cache array generated by DataObject::ExportCache
     *
     * @return TRUE             on success
     * @throws RuntimeException
     */
    final public static function ImportCache($cache)
    {
        $unserialize = @unserialize($cache);
        if ($unserialize === false) {
            throw new RuntimeException(sprintf(self::$exceptions[11], $cache, __METHOD__), 11);
        }

        self::$do_cache = unserialize($cache);

        return true;
    }

    /**
     * Default constructor.
     *
     * @param array|DataObject $data array of key/value pairs matching properties of data object or a parent DataObject.
     */
    public function __construct($data = array())
    {
        $this->initialize();
        $this->import($data);
    }

    /**
     * Initialize the definition arrays.
     *
     * @throws RuntimeException
     */
    protected function initialize()
    {
        $this->iterator_pos = 0;
        $this->called_class = get_called_class();

        if (isset(self::$do_cache[$this->called_class])) {
            $cache                      = self::$do_cache[$this->called_class];
            $this->type_map             = $cache['type_map'];
            $this->cast_map             = $cache['cast_map'];
            $this->definition_defaults  = $cache['definition_defaults'];
            $this->definition_keys      = $cache['definition_keys'];
            $this->definition_types     = $cache['definition_types'];
            $this->definition_values    = $cache['definition_values'];

            foreach ($this->definition_keys as $key) {
                unset($this->$key);
            }

            return;
        }

        foreach (explode('|', self::TYPE_MAP_ALLOWED) as $type) {
            $this->type_map[$type] = $type;
        }

        foreach (explode('|', self::CAST_MAP_ALLOWED) as $cast) {
            $this->cast_map[$cast] = $cast;
        }

        $reflection = new ReflectionClass($this->called_class);
        $public_vars = $reflection->getProperties(ReflectionProperty::IS_PUBLIC);
        $this->definition_defaults = $reflection->getDefaultProperties();

        foreach ($public_vars as $public_var) { /* @var ReflectionProperty $public_var */
            $doc = $public_var->getDocComment();
            $key = $public_var->getName();
            $is_static = $public_var->isStatic();

            if ($is_static) {
                unset($this->definition_defaults[$key]);
                continue;
            }

            $type = preg_match('/@var\s+([^\s]+)/i', $doc, $matches) ? $matches[1] : 'mixed';

            if (strpos($type, '|')) {
                throw new RuntimeException(
                    sprintf(self::$exceptions[1], $type, $key, $this->called_class), 1
                );
            }

            if (!isset($this->type_map[$type]) && $type !== 'mixed' && !class_exists($type)) {
                throw new RuntimeException(
                    sprintf(self::$exceptions[2], $type, $key, $this->called_class), 2
                );
            }

            $this->definition_keys[]        = $key;
            $this->definition_types[$key]   = $type;
            $this->definition_values[$key]  = $this->definition_defaults[$key];

            unset($this->$key);
        }

        self::$do_cache[$this->called_class] = array(
            'type_map' => $this->type_map,
            'cast_map' => $this->cast_map,
            'definition_defaults' => $this->definition_defaults,
            'definition_keys' => $this->definition_keys,
            'definition_types' => $this->definition_types,
            'definition_values' => $this->definition_values,
        );
    }

    /**
     * Add a phpdoc type to the type map.
     *
     * @param string $type
     * @param string $mapped_type Any value found in DataObject::TYPE_MAP_ALLOWED
     *
     * @throws RuntimeException
     */
    final protected function typeMapAdd($type, $mapped_type)
    {
        if (!in_array($mapped_type, explode('|', self::TYPE_MAP_ALLOWED))) {
            throw new RuntimeException(
                sprintf(self::$exceptions[3], $mapped_type, $type), 3
            );
        }

        $this->type_map[$type] = $mapped_type;
    }

    /**
     * Add a phpdoc type to the cast map.
     *
     * @param string $type
     * @param string $cast_type Any value found in DataObject::CAST_MAP_ALLOWED
     *
     * @throws RuntimeException
     */
    final protected function castMapAdd($type, $cast_type)
    {
        if (!in_array($cast_type, explode('|', self::CAST_MAP_ALLOWED))) {
            throw new RuntimeException(
                sprintf(self::$exceptions[4], $cast_type, $type), 4
            );
        }

        $this->cast_map[$type] = $cast_type;
    }

    /**
     * Generate a hash of the values in this object.
     *
     * @param string $type
     * @param string $prefix
     * @param string $suffix
     * @param array  $ignore_keys Optional list of vars to ignore.
     *
     * @return string
     */
    public function hash($type = self::HASH_TYPE_SHA256, $prefix = '', $suffix = '', $ignore_keys = array())
    {
        $copy = $this->export();

        if (is_array($ignore_keys) && $ignore_keys) {
            foreach ($ignore_keys as $key) {
                unset($copy[$key]);
            }
        }

        return hash($type, $prefix . implode('', array_values($copy)) . $suffix);
    }

    /**
     * Return data in query string format
     *
     * @return string
     */
    public function queryString()
    {
        return http_build_query($this->definition_values);
    }

    /**
     * Output dump of properties handled by DataObject.
     *
     * @param boolean $html
     * @param boolean $return
     * @param string  $prefix
     */
    final public function dump($html = true, $return = false, $prefix = '')
    {
        $out = array();

        $len = count($this->definition_keys);
        $out[] = "$prefix <span style='color:#00a;'>$this->called_class</span> ($len) {";
        $prefix .= str_pad('', 4);

        $out = array_merge($out, $this->dumpArray($this->definition_values, $prefix));

        $out[] = "$prefix }";
        $prefix = substr($prefix, 0, -4);

        if ($return) {
            return $out;
        } else {
            $result = PHP_EOL . implode(PHP_EOL, $out) . PHP_EOL;
            echo $html ? "<pre style='color:#555;'>$result</pre>" : strip_tags($result);
        }
    }

    /**
     * Process array for dump output.
     *
     * @param array  $array
     * @param string $prefix
     *
     * return array
     */
    final protected function dumpArray(&$array, $prefix = '')
    {
        $out = array();
        foreach ($array as $key => $val) {
            if (isset($this->$key)) {
                $val = $this->$key;
            }

            $type = gettype($val);
            $defined_type = isset($this->definition_types[$key]) ? $this->definition_types[$key] : $type;

            if (in_array($type, array('array', 'object'))) {
                $len = count($val);
                $sub = array();

                if ($type === 'object' && $val instanceof DataObject) {
                    //$prefix .= str_pad('', 4);
                    $sub = $val->dump(true, true, $prefix);
                    //$prefix = substr($prefix, 0, -4);

                    $sub[0] = str_replace($prefix, "$prefix [<span style='color:#090;'>$key</span>]", $sub[0]);
                    $out = array_merge($out, $sub);
                } else {
                    $out[] = "$prefix [<span style='color:#090;'>$key</span>] <span style='color:#00a;'>$defined_type</span> ($len) {";
                    $prefix .= str_pad('', 4);

                    $sub = $this->dumpArray($val, $prefix);
                    $out = array_merge($out, $sub);

                    $out[] = "$prefix }";
                    $prefix = substr($prefix, 0, -4);
                }
            } else {
                $len = strlen($val);
                if ($type === 'string') {
                    $val = "\"$val\"";
                } elseif (is_bool($val)) {
                    $val = $val ? 'true' : 'false';
                } elseif (is_null($val)) {
                    $val = "<em style='color:#999;'>null</em>";
                }
                $out[] = "$prefix [<span style='color:#090;'>$key</span>] <span style='color:#00a;'>$defined_type</span> ($len) => <span style='color:#a00;'>$val</span>";
            }
        }

        return $out;
    }

    /**
     * Return json encoded or json-ready structural representation of object.
     *
     * @param boolean $encoded
     */
    final public function json($encode = true)
    {
        $result = $this->jsonArray($this->definition_values);

        if ($encode) {
            return json_encode($result);
        }

        return $result;
    }

    /**
     * Process array to make a json-ready structural representation of object.
     *
     * @param array $array
     *
     * @return array
     */
    final protected function jsonArray(&$array)
    {
        $result = array();

        foreach ($array as $key => $val) {
            if (isset($this->$key)) {
                $val = $this->$key;
            }

            if ($val instanceof self) {
                $result[$key] = $val->json(false);
            } elseif (is_array($val) || is_object($val)) {
                $val = (array) $val;
                $result[$key] = $this->jsonArray($val);
            } else {
                $result[$key] = $val;
            }
        }

        return $result;
    }

    /**
     * Return an array representation of class properties and values.
     *
     * @return array
     */
    final public function export()
    {
        return $this->jsonArray($this->definition_values);
    }

    /**
     * Import an array of values into the data object. Array keys should match
     * DataObject properties.
     *
     * @param array $data
     */
    public function import($data)
    {
        if (empty($data)) {
            return;
        }

        // handle data as a string.
        if (is_string($data)) {
            // looking for json
            $decoded = json_decode($data, true);
            if (!is_null($decoded)) {
                return $this->import($decoded);
            }

            // looking for serialized.
            $unserialized = unserialize($data);
            if ($unserialized !== false) {
                return $this->import($decoded);
            }

        // handle data as an array.
        } elseif (is_array($data)) {

            foreach ($this->definition_keys as $key) {
                $val = $this->definition_defaults[$key];
                if (array_key_exists($key, $data)) {
                    $val = $data[$key];
                }
                $this->_set($key, $val, true);
            }

        // handle data as a instance/child of DataObject.
        } elseif ($data instanceof DataObject) {
            foreach ($this->definition_keys as $key) {
                $val = $this->definition_defaults[$key];
                if ($data instanceof DataObject && isset($data->$key)) {
                    $val = $data->$key;
                }
                $this->_set($key, $val, true);
            }
        }
    }

    /**
     * Retrieve the type for a specified property.
     *
     * @param string $name
     *
     * @return string
     *
     * @throws RuntimeException
     */
    public function getType($name)
    {
        if (!in_array($name, $this->definition_keys)) {
            throw new RuntimeException(
                sprintf(self::$exceptions[5], $name, $this->called_class), 5
            );
        }

        return $this->definition_types[$name];
    }

    /**
     * Magic getter.
     *
     * @param string $name
     *
     * @return mixed
     */
    public function &__get($name)
    {
        return $this->_get($name);
    }

    /**
     * Method for magic getter and private use.
     *
     * @param string $name
     *
     * @return mixed
     *
     * @throws RuntimeException
     */
    protected function &_get($name)
    {
        if (!in_array($name, $this->definition_keys)) {
            throw new RuntimeException(
                sprintf(self::$exceptions[6], $name, $this->called_class), 6
            );
        }

        return $this->definition_values[$name];
    }

    /**
     * Magic setter.
     *
     * @param string $name
     * @param mixed  $value
     */
    public function __set($name, $value)
    {
        $this->_set($name, $value);
    }

    /**
     * Method for magic setter and private use.
     *
     * @param string  $name
     * @param mixed   $value
     * @param boolean $graceful skip exceptions for non existant properties.
     *
     * @throws RuntimeException
     */
    protected function _set($name, $value, $graceful = false)
    {
        if (!in_array($name, $this->definition_keys)) {
            if ($graceful) {
                return;
            }
            throw new RuntimeException(
                sprintf(self::$exceptions[7], $name, $this->called_class), 7
            );
        }

        if (!is_null($value) && isset($this->definition_types[$name])) {
            $expected_type = $this->definition_types[$name];

            if ($graceful) {
                $expected_type = 'mixed';
            }

            $mapped_type = isset($this->type_map[$expected_type]) ?
                    $this->type_map[$expected_type] : $this->type_map['*'];

            $cast_type = isset($this->cast_map[$expected_type]) ?
                    $this->cast_map[$expected_type] : null;

            if (!is_null($cast_type) && is_scalar($value)) {
                $casted = self::CastVar($value, $cast_type);

                if ($value == $casted) {
                    $value = $casted;
                }
                unset($casted);
            }

            if ($expected_type !== 'mixed' && (!call_user_func("is_$mapped_type", $value) ||
                ($mapped_type == 'object' && !$value instanceof $expected_type))) {
                $value_type = gettype($value);
                throw new RuntimeException(
                    sprintf(self::$exceptions[8],
                            $name, $this->called_class, $expected_type,
                            $value_type, var_export($value, true)
                    ), 8
                );
            }
        }

        $this->definition_values[$name] = $value;
    }

    /**
     * Set parameter by name
     *
     * @param string $name  The key you want to set
     * @param mixed  $value The value you want to set
     *
     * @return self
     */
    public function setParam($name, $value)
    {
        $this->_set($name, $value);

        return $this;
    }

    /**
     * Magic isset.
     *
     * @param string $name The key where you looking for
     *
     * @return boolean Wheter the value exists or not
     */
    public function __isset($name)
    {
        if (!in_array($name, $this->definition_keys)) {
            return false;
        }

        return true;
    }

    /**
     * Magic unset.
     *
     * @param string $name
     *
     * @throws RuntimeException
     */
    public function __unset($name)
    {
        if (in_array($name, $this->definition_keys) === false) {
            throw new RuntimeException(
                sprintf(self::$exceptions[9], $name, $this->called_class), 9
            );
        }

        unset($this->definition_values[$name]);
    }

    /**
     * Handle necessary cleanup before serializing instance of DataObject.
     *
     * @return returns a serialized array of the object
     */
    public function serialize()
    {
        return serialize($this->definition_values);
    }

    /**
     * Handle necessary initialization for unserializing instance of DataObject.
     *
     * @param  serialized $serialized The serialized created by the DataObject::serialize()
     * @return self
     *
     * @throws RuntimeException
     */
    public function unserialize($serialized)
    {
        $this->initialize();

        $unserialized = @unserialize($serialized); // I'll catch the error and handle it

        if ($unserialized === false) {
            throw new RuntimeException(sprintf(self::$exceptions[11], $serialized, __METHOD__), 11);
        }

        $this->definition_values = unserialize($serialized);

        return $this;
    }

    /**
     * Cast a value to the desired type.
     *
     * @param mixed  $value The value you went to cast
     * @param string $type  The type you want to cast to
     *
     * @return mixed
     *
     * @throws RuntimeException
     */
    final public static function CastVar($value, $type)
    {
        switch ($type) {
            case 'int':
            case 'integer':
                if (is_numeric($value)) {
                    $value = (integer) $value;
                }
                break;
            case 'bool':
            case 'boolean':
                $value = (boolean) $value;
                break;

            case 'float':
            case 'double':
            case 'real':
                $value = (float) $value;
                break;

            case 'string':
                $value = (string) $value;
                break;

            case 'array':
                $value = (array) $value;
                break;

            case 'object':
                $value = (object) $value;
                break;

            case 'unset':
                $value = (unset) $value;
                break;

            default:
                throw new RuntimeException(
                    sprintf(self::$exceptions[10], $type), 10
                );
        }

        return $value;
    }

    /*
     * Iterator implementation.
     */
    final public function current()
    {
        $pos = $this->iterator_pos;
        $name = $this->definition_keys[$pos];

        return $this->$name;
    }

    final public function key()
    {
        $pos = $this->iterator_pos;
        $name = $this->definition_keys[$pos];

        return $name;
    }

    final public function next()
    {
        ++$this->iterator_pos;
    }

    final public function rewind()
    {
        $this->iterator_pos = 0;
    }

    final public function valid()
    {
        $pos = $this->iterator_pos;

        if ($pos < count($this->definition_keys)) {
            $name = $this->definition_keys[$pos];

            return isset($this->$name);
        }

        return false;
    }

}
